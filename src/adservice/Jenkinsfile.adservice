pipeline {
    agent { label 'dev' }
    parameters {
        booleanParam(name: 'PUSH_TO_ECR', defaultValue: true, description: 'Push image to AWS ECR')
        booleanParam(name: 'PUSH_TO_ARTIFACTORY', defaultValue: false, description: 'Push image to JFrog Artifactory')
        booleanParam(name: 'PUSH_TO_DOCKERHUB', defaultValue: false, description: 'Push image to DockerHub')
    }

    environment {
        REPO_URL = 'https://github.com/kapilkumaria/microservices-demo-sample.git' // Repository URL
        SONARQUBE_SERVER = 'sonarQube' // SonarQube server name configured in Jenkins
        SONARQUBE_URL = 'http://52.2.64.174:9000' // SonarQube server URL
        SONARQUBE_TOKEN = credentials('sonar-token') // SonarQube token stored in Jenkins
        SERVICE_NAME = 'adservice' // Specific service name for this Jenkinsfile
        ECR_REPO_MICROSERVICES = '931058976119.dkr.ecr.us-east-1.amazonaws.com/gcp-adservice'
        PATH = "/opt/sonar-scanner/sonar-scanner-4.8.0.2856-linux/bin:${env.PATH}"                    
    }

    stages {
        stage('Clone Repository') {
            steps {
                echo "Cloning the repository from ${REPO_URL} for ${SERVICE_NAME}"
                git url: "${REPO_URL}", branch: 'feature/jenkinsfile-adservice' // Clone specified branch
            }
        }
        
        stage('SonarQube Analysis') {
            steps {
                script {
                    withSonarQubeEnv('sonarQube') {

                                   sh """
                                        cd src/adservice
                                        chmod +x ./gradlew
                                        ./gradlew sonarqube || true \
                                            --init-script /root/.gradle-init/init.gradle \
                                            --no-daemon \
                                            -Dsonar.projectKey=${SERVICE_NAME} \
                                            -Dsonar.sources=. \
                                            -Dsonar.host.url=$SONARQUBE_URL \
                                            -Dsonar.login=$SONARQUBE_TOKEN
                                    """
                    }
                }
           }
        }

        stage('Build Docker Image') {
            steps {
                echo "Building Docker image for ${SERVICE_NAME}"
                sh """
                    docker build -t ${SERVICE_NAME}:latest -f src/adservice/Dockerfile src/adservice
                """
            }
        }

        stage('Trivy Scan for Docker Web Image') {
            steps {
                sh "trivy image --severity HIGH,CRITICAL --exit-code 0 --scanners vuln ${SERVICE_NAME}:latest"
            }
        }

        stage('Push AdService Image to AWS ECR') {
            when {
                expression { params.PUSH_TO_ECR }
            }
    
            steps {
               withCredentials([
                    string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
                    string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY'),
                    
                ]) {
                    sh '''
                      aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 931058976119.dkr.ecr.us-east-1.amazonaws.com
                      docker tag ${SERVICE_NAME}:latest ${ECR_REPO_MICROSERVICES}:${BUILD_NUMBER}
                      docker push ${ECR_REPO_MICROSERVICES}:${BUILD_NUMBER}
                    '''
                    }
            }
         }

         
        stage('Push AdService Image to JFrog Artifactory') {
            when {
                expression { params.PUSH_TO_ARTIFACTORY }
            }
            steps {
              withCredentials([
                    string(credentialsId: 'JFROG_URL', variable: 'JFROG_URL'),
                    string(credentialsId: 'JFROG_USERNAME', variable: 'JFROG_USERNAME'),
                    string(credentialsId: 'JFROG_TOKEN', variable: 'JFROG_TOKEN'),
                    string(credentialsId: 'JFROG_IMAGE_TAG', variable: 'JFROG_IMAGE_TAG')                    
                ]) {
                sh '''
 
                  echo "$JFROG_TOKEN" | docker login "$JFROG_URL" --username "$JFROG_USERNAME" --password-stdin

                  docker tag $SERVICE_NAME:latest $JFROG_IMAGE_TAG/$SERVICE_NAME:$BUILD_NUMBER
                  docker push $JFROG_IMAGE_TAG/$SERVICE_NAME:$BUILD_NUMBER
                '''
                echo "Web image pushed to JFrog Artifactory successfully."
                }
            }
        }

         stage('Push AdService Image to DockerHub') {
            when {
                expression { params.PUSH_TO_DOCKERHUB }
            }
            steps {
              withCredentials([
                    string(credentialsId: 'DOCKERHUB_URL', variable: 'DOCKERHUB_URL'), 
                    string(credentialsId: 'DOCKERHUB_USERNAME', variable: 'DOCKERHUB_USERNAME'),
                    string(credentialsId: 'DOCKERHUB_TOKEN', variable: 'DOCKERHUB_TOKEN'),
                    string(credentialsId: 'DOCKERHUB_IMAGE_TAG', variable: 'DOCKERHUB_IMAGE_TAG'),

              ]) {
                sh '''
                  echo "$DOCKERHUB_TOKEN" | docker login "$DOCKERHUB_URL" --username "$DOCKERHUB_USERNAME" --password-stdin
                  docker tag $SERVICE_NAME:latest $DOCKERHUB_IMAGE_TAG/$SERVICE_NAME:$BUILD_NUMBER
                  docker push $DOCKERHUB_IMAGE_TAG/$SERVICE_NAME:$BUILD_NUMBER
                '''
                echo "Web image pushed to DockerHub successfully."
                }
            }
        }

        stage('Update Kubernetes Manifest for ArgoCD') {
            steps {
                script {
                    def manifestFile = "kubernetes-manifests/adservice.yaml"

                    withCredentials([
                        string(credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN'),
                        string(credentialsId: 'DOCKERHUB_IMAGE_TAG', variable: 'DOCKERHUB_IMAGE_TAG')
                    ]) {
                        // Stash any changes if needed
                        sh 'git stash'

                        // Check out the branch with the Kubernetes manifests
                        sh 'git fetch origin feature/kubernetes-manifests'
                        sh 'git checkout feature/kubernetes-manifests'

                        // Pull latest changes with rebase and handle conflicts
                        try {
                            sh 'git pull origin feature/kubernetes-manifests --rebase'
                        } catch (Exception e) {
                            echo "Rebase conflict encountered. Aborting rebase."
                            sh 'git rebase --abort'
                            error("Rebase failed due to conflicts. Please resolve manually.")
                        }

                        // Modify the manifest file with the new DockerHub image tag
                        def newImageTag = "${DOCKERHUB_IMAGE_TAG}/${SERVICE_NAME}:${BUILD_NUMBER}"
                        sh """
                            export DOCKERHUB_IMAGE_TAG=${DOCKERHUB_IMAGE_TAG}
                            export SERVICE_NAME=${SERVICE_NAME}
                            export BUILD_NUMBER=${BUILD_NUMBER}
                            sed -i 's|image: .*|image: ${newImageTag}|g' ${manifestFile}
                        """

                        // Commit and push the changes to the kubernetes manifests branch
                        sh """
                            git config user.name "jenkins-bot"
                            git config user.email "jenkins-bot@yourdomain.com"
                            git add ${manifestFile}
                            git commit -m "Update image tag for ${SERVICE_NAME} to DockerHub ${BUILD_NUMBER}" || true
                            git push https://jenkins-bot:${GITHUB_TOKEN}@github.com/kapilkumaria/microservices-demo-sample.git HEAD:feature/kubernetes-manifests
                        """

                        // Return to the original branch (if required)
                        sh 'git checkout feature/jenkinsfile-adservice'
                        
                        // Apply the stashed changes back (if any)
                        sh 'git stash pop || true'
                    }
                }
            }
        }
    }

    post {
        success {
            echo "Pipeline completed successfully for ${SERVICE_NAME}!"
        }
        failure {
            echo "Pipeline failed for ${SERVICE_NAME}. Please check logs for details."
        }
    }
}

